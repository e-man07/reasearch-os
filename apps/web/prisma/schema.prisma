// Prisma schema for ResearchOS

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String?
  passwordHash  String?   @map("password_hash")
  role          Role      @default(USER)
  isActive      Boolean   @default(true) @map("is_active")
  isVerified    Boolean   @default(false) @map("is_verified")
  
  projects      Project[]
  searches      Search[]
  
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastLoginAt   DateTime? @map("last_login_at")
  
  @@map("users")
}

enum Role {
  USER
  ADMIN
  RESEARCHER
}

model Paper {
  id              String    @id @default(uuid())
  title           String
  abstract        String    @db.Text
  
  // Identifiers
  doi             String?
  arxivId         String?   @map("arxiv_id")
  pubmedId        String?   @map("pubmed_id")
  semanticScholarId String? @map("semantic_scholar_id")
  
  // Metadata
  year            Int
  month           Int?
  venue           String?
  publisher       String?
  
  // URLs
  pdfUrl          String?   @map("pdf_url")
  htmlUrl         String?   @map("html_url")
  
  // Classification
  topics          String[]
  keywords        String[]
  categories      String[]
  
  // Metrics
  citations       Int?
  
  // Source
  source          String
  sourceId        String    @map("source_id")
  rawJson         Json?     @map("raw_json")
  
  chunks          Chunk[]
  
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  publishedAt     DateTime? @map("published_at")
  
  @@unique([source, sourceId])
  @@index([arxivId])
  @@index([doi])
  @@map("papers")
}

model Chunk {
  id              String   @id @default(uuid())
  paperId         String   @map("paper_id")
  paper           Paper    @relation(fields: [paperId], references: [id], onDelete: Cascade)
  
  content         String   @db.Text
  chunkIndex      Int      @map("chunk_index")
  
  section         String?
  sectionIndex    Int?     @map("section_index")
  page            Int?
  
  embeddingModel  String?  @map("embedding_model")
  metadata        Json?
  
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  @@index([paperId])
  @@map("chunks")
}

model Project {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name            String
  description     String?  @db.Text
  query           String?
  
  status          ProjectStatus @default(ACTIVE)
  
  searches        Search[]
  
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  @@index([userId])
  @@map("projects")
}

enum ProjectStatus {
  ACTIVE
  ARCHIVED
  DELETED
}

model Search {
  id              String   @id @default(uuid())
  projectId       String?  @map("project_id")
  project         Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)
  userId          String   @map("user_id")
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  query           String
  filters         Json?
  
  status          SearchStatus @default(PENDING)
  errorMessage    String?  @map("error_message") @db.Text
  executionTimeMs Int?     @map("execution_time_ms")
  
  totalResults    Int      @default(0) @map("total_results")
  
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  startedAt       DateTime? @map("started_at")
  completedAt     DateTime? @map("completed_at")
  
  @@index([userId])
  @@index([projectId])
  @@map("searches")
}

enum SearchStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}
